#!/usr/bin/perl
#
# Copyright (C) 2001 Stephane Carrez
#
# This file is part of SCT
#
# SCT is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2 of the License, or
# (at your option) any later version.
#
# SCT is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the Free Software
# Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
#
# ######################################################################
sub help { select(STDERR); print <<EOF;

Generate a table of HTML entity strings for Ada

Usage:	gen-ada-entities.pl [-v] symbol.ent ...

EOF

    exit(0);
}

sub message {
    local($msg) = @_;

    if ($verbose) {
	  print STDOUT "$Indent$msg";
    }
}

$errors_count = 0;
sub error {
    local($msg) = @_;

    print STDERR "$msg\n";
    $errors_count++;
}

$SEP="/";
$|=1;

$max_len = 0;
local(%keywords);

sub ReadEntities {
    local($file) = @_;
    local($cmd) = "";

    if (!open(FILE, "$file")) {
        &error("Cannot read $file");
		return "";
    }
    while (<FILE>) {
        chop;
		if (/^<!ENTITY/) {
		  @names = split(" ", $_);
		  $val = $names[2];
		  $val =~ s/"&#//;
          $val =~ s/;".*//;
		  $len = length($names[1]);
		  if ($len > $max_len) {
			$max_len = $len;
		  }
		  # printf("%s=%s\n", $names[1], $val);
		  $keywords{$names[1]} = $val;
		}
	  }
    close(FILE);
}
sub ToAda {
  local($name) = @_;

  $name =~ tr/abcdefghijklmnopqrstuvwxyz/ABCDEFGHIJKLMNOPQRSTUVWXYZ/;
  return $name;
}
sub sortFunc {
  local($a,$b) = @_;

  if ($a eq $b) {
     return 0;
  } elsif ($a le $b) {
     return -1;
  } else {
     return 1;
  }
}

printf("--  Generated by gen-ada-entities.pl");
while (@ARGV) {
  $_ = shift;
  printf(" $_");
  &ReadEntities($_);
}
printf("\n");
printf("private package Wiki.Parsers.Html.Entities is\n");
printf("\n");
printf("   pragma Preelaborate;\n");
printf("\n");

$max_len += 5;
local(@names) = sort { &sortFunc($a, $b) } keys %keywords;
local(@ada_names);
$cnt = 0;
for (@names) {
    $name = $_;
	$ada_name = &ToAda($name);
	if ($ada_name ~~ @ada_names) {
	  $ada_name = sprintf("N%d", $cnt);
	}
	push(@ada_names, $ada_name);
    printf("   %*s : aliased constant String := \"%s\";\n",
	  -$max_len,  $ada_name . "_NAME", $name);
    $cnt = $cnt + 1;
}
printf("\n");
printf("   type String_Access is access constant String;\n");
printf("   type Keyword_Array is array (Positive range 1 .. %d) of String_Access;\n", $cnt);
printf("   type Char_Array is array (Positive range 1 .. %d) of Wide_Wide_Character;\n", $cnt);
printf("\n");
print("   Keywords : constant Keyword_Array := (\n");
$cnt = 0;
for (@ada_names) {
    $name = $_;
    if ($cnt > 0) {
      print(",\n");
    }
    printf("      %s_NAME'Access", $name);
    $cnt = $cnt + 1;
}
print(");\n\n");
print("   Mapping : constant Char_Array := (\n");
$cnt = 0;
for (@names) {
  $name = $_;
  $val = $keywords{$name};
  if ($cnt > 0) {
	print(",\n");
  }
  printf("      Wide_Wide_Character'Val (%s)", $val);
  $cnt = $cnt + 1;
}
print(");\n");
printf("end Wiki.Parsers.Html.Entities;\n");



